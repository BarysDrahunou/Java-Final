Условие проекта Elevator Имеется многоэтажное здание, в котором есть 1
лифт определенной вместимости. На этажах здания расставлены люди,
которые хотят переместится на другой этаж. Нужно организовать перевозку
людей при помощи лифта. Исходные данные - количество этажей здания
(floorsNumber). - вместимость кабины лифта (человек) (elevatorCapacity).
- общее количество людей для перевозки (passengersNumber). Исходные
данные нужно хранить в config.properties файле в виде пар:
ключ/значение. Инициализация после запуска приложения - cначала
считываются параметры из config файла. - затем создаются требуемое
количество (passengersNumber) экземпляров пассажиров (Passenger),
которые случайным образом (более-менее равномерно) расставляются по
этажам. Имеется ввиду, что на каждом этаже создается т.н. контейнер
отправления (dispatchFloorContainer), куда и помещаются некоторые
Passengers для их последующего перевозки лифтом. У каждого пассажира
есть свойство "этаж назначения" (arrivalFloorContainer), которое тоже
инициализируется случайным образом, разумеется исключая исходный этаж,
на котором пассажир ожидает своей перевозки. Кроме того каждому
экземпляру Passenger задается уникальный номер (passengerID). Запуск
процесса перевозки - для каждого пассажира создается свой
TranportationTask, который имплементируется средствами Java, как
отдельный Thread. - для лифта создается отдельный MovementTask, который
имплементируется средствами Java, как отдельный Thread. - после этого
основной Thread программы стартует работу экземпляров TranportationTask
и MovementTask по циклическому передвижению лифта между этажами (начиная
с 1-го этажа до последнего) вверх-вниз-вверх-вниз... - всю работу по
управлению лифтом берет на себя некоторый оператор (Controller).
Например, как это было в старых лифтах, когда в кабине лифта находился
специальный человек, который запускал/останавливал лифт,
открывал/закрывал двери, а также впускал туда и выпускал оттуда людей.
Таким образом, кабина лифта является контейнером (evelvatorContainer)
ограниченного размера, в который помещаются перевозимые люди. Процесс
перевозки - оператор перемещает лифт последовательно между этажами в
цикле вверх-вниз. - оператор останавливает лифт на каждом этаже. -
сначала он сообщает людям, находящимся в кабине лифта, что лифт прибыл
на такой-то этаж и можно выходить. - те из них, кому нужно выйти именно
на этом этаже, просит оператора выпустить его. - оператор делает высадку
человека из кабины лифта, точнее его перемещение из кабины лифта
(evelvatorContainer) в контейнер прибытия (arrivalFloorContainer). Таким
образом, на каждом этаже имеется свой контейнер прибытия, куда
помещаются прибывшие на этаж назначения люди. На этом TransportationTask
по перевозке человека на этаж назначения считается выполненным и
соответствующий Thread завершается. - когда оператор выпустил прибывших
на свой этаж назначения людей из кабины лифта, он потом сообщает людям,
стоящим на этаже в ожидании своей перевозки, т.е. находящимся в
контейнере dispatchFloorContainer, что можно заходить в кабину лифта.
После этого каждый человек, ждущий перевозки, просит оператора впустить
его в кабину лифта. Оператор по одному человеку осуществляет посадку в
кабину лифта, т.е. перемещает человека из контейнера отправления
(dispatchFloorContainer) в контейнер кабины лифта (evelvatorContainer).
Оператор делает это до тех пор, пока либо не закончатся места в кабине
лифта, либо не закончатся люди в контейнере отправления. - после
окончания всех операций высадки/посадки оператор перемещает лифт на
следующий этаж. Окончание процесса перевозки Когда не останется ни в
одном из контейнеров отправления и контейнере лифта ни одного человека,
процесс перевозки заканчивается и оператор останавливает лифт. После
этого все TransportationTask считаются завершенными и все
соответствующие им Thread должны быть завершены. Состояние процесса
перевозки для отдельного человека У каждого пассажира есть свойство
"состояние перевозки" (transportationState), которое может принимать
значения: - NOT\_STARTED (этим значением поле инициализируется при
создании экземпляра Passenger) - IN\_PROGRESS (когда создается
Transportation Task) - COMPLETED (когда завершается Transportation Task)
Состояние перевозки Passenger (TransportationState) может менять только
ассоциированный TransportationTask. Общее текущее/завершенное/прерванное
состояние процесса перевозки Это список состояний по каждому
перевозимому человеку, а именно: - в каком из контейнеров
(dispatchFloorContainer, evelvatorContainer, arrivalFloorContainer) он
находится. - каков его transportationState

Валидация правильности завершения процесса перевозки Следующие проверки
должны быть выполнены: - все контейнеры отправления
(dispatchFloorContainer) должны быть пусты. - контейнер кабины лифта
(evelvatorContainer) должен быть пуст. - в контейнерах прибытия
(arrivalFloorContainer) у всех людей, которые там находятся,
transportationState должен быть COMPLETED, и этаж назначения
(destinationFloor) должен совпадать с номером этажа, с которым
ассоциирован соответствующий arrivalFloorContainer. - суммарное
количество людей по всем arrivalFloorContainer должно совпадать с
passengersNumber. Логирование процесса перевозки Процесс перевозки
осуществляется через определенные действия оператора (actions). Такие
как: - STARTING\_TRANSPORTATION - запуск процесса перевозки. -
COMPLETION\_TRANSPORTATION - завершение процесса перевозки. -
MOVING\_ELEVATOR (from floor-N to floor-M) - перемещение лифта с этажа
на этаж. - BOADING\_OF\_PASSENGER (passangerID on floor-N) - посадка
пассажира на этаже. - DEBOADING\_OF\_PASSENGER (passangerID on floor-N)
- высадка пассажира на этаже. Все actions за время процесса перевозки
должны записываться в специальный log file(s). После завершения процесса
выполняется "Валидация правильности завершения процесса перевозки",
результаты которой записываются в лог файл, а также выводятся в консоль.
Условия имлементации Компиляция и запуск приложения должны
осуществляться посредством любого build tool на ваш выбор из списка:
Apache Ant, Apache Maven, Gradle. Таск должен быть выполнен по TTD.
Многопоточность не тестировать! Тестировать только логику! Разрешается
использовать любой популярный логер кроме стандартного
java.util.logging.Logger. Рекомендуется использовать для реализации
записи в лог файл: SLF4J (routed to Apache Log4j 2). Также следует
создать минимальную документацию, которая будет описывать процесс
запуска приложения. Для этого нужно создать README файл в корне проекта
и описать в нем проект, параметры для запуска, собственно запуск. Проект
должен хранится в private Git репозитории. Ограничения, накладываемые на
реализацию многопоточности 1. Все потоки создаются с помощью
ThreadPoolExecutor (или иных классов из пакета java.util.concurrent).
Запрещается создавать потоки вручную через new Thread().start(); 2.
Запрещено пользоваться любыми многопоточными коллекциями! UML-диаграмма
основных классов и зависимостей предоставляется вам в помощь как
ориентир:

     Также (преимущественно для тех, кто еще учится читать UML-диаграммы), можно воспользоваться ссылкой на репозиторий с этими же классами:

https://github.com/YauhenPiatsevich/elevator-template Предложенный
шаблон (репозитарий) можно смело клонировать и использовать у себя в
проекте без изменений. Впрочем, отступать от шаблона (изменять, удалять,
добавлять что-либо) не запрещено! Факультативно предлагается усложнить
задание следующим образом: - вместо 1 лифта сделать 2 и более лифтов
добавив новый инициализационный параметр (elevatorsNumber) в файл
config.properties. - сделать программу анимированной (с нарисованным
зданием и анимацией перехода пассажиров в/из лифта). Разрешается
использовать любую графическую библиотеку, технологию и среду
исполнения, но при этом свою реализацию многопоточности, написанную на
Java. - сделать анимированную программу бесконечной, добавив возможность
пассажиров входить и выходить из здания. - добавить в анимированную
программу кнопки управления (старт, пауза, продолжить и динамическую
регулировку скорости анимации).
